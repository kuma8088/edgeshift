# モデル品質劣化対策（常時適用）

> Opus 4.5 Nerf 問題（2025年11月）から学んだ実践的教訓
> pathsを指定しないため、すべての操作で読み込まれます

---

## 禁止事項

### モデルの勝手な変更を絶対に行わない

```
実例：
  - ユーザー指定: Gemini 3
  - Claude が変更: Gemini 2 Flash（存在しないと誤判断）

ルール：
  - ユーザーが指定したモデルは絶対に変更しない
  - 「このモデルは存在しない」と思っても、変更前に必ず確認
```

### Reward Hacking を行わない

```
定義: 問題を解決せず誤魔化す行為

禁止パターン：

  1. エラーを隠すためのコメントアウト
     // TODO: Fix later - this function causes issues
     // function processPayment() { ... }

  2. 「後で直す」fallback
     try {
       await criticalOperation();
     } catch (e) {
       return null; // Fallback for now
     }

  3. フェイクログ
     console.log('Success!');
     // 実際のエラー処理なし

  4. 問題のある依存を削除
     // import { problematicModule } from './module';
```

### Vibe Coding を許さない

```
定義: AIに丸投げして監視しない開発スタイル

問題点:
  - コードの意図が理解できない
  - Reward Hacking を見逃す
  - モデル変更を見逃す
  - 技術的負債が蓄積

推奨: AI Augmented Coding への移行
  - AI がコーディング、人間がプログラミング（設計・判断）
  - 各変更を監視し、承認する
  - Plan Mode で事前に計画を確認
```

---

## 必須行動

### 問題が解決できない場合、正直に報告

```
良い例:
  「この実装には〇〇の問題があり、解決方法を3つ検討しました:
   1. 〇〇（推奨、理由: 〜）
   2. △△（代替案、トレードオフ: 〜）
   3. ××（非推奨、理由: 〜）
   どの方針で進めますか？」
```

### モデル変更が必要な場合、承認を求める

```
例:
  「指定されたモデルでは〇〇の機能がサポートされていない可能性があります。

   選択肢:
   1. 指定通り [モデル名] で続行（推奨）
   2. 代替モデルに変更（要承認）

   どちらで進めますか？」
```

### エッジケースを事前にリストアップ

```
実装前に考慮すべきケース:
  1. 入力が空の場合
  2. 入力が異常に大きい場合
  3. ネットワークエラーが発生した場合
  4. 権限がない場合
  5. 並行実行された場合
  6. データが存在しない場合
```

---

## モデル劣化の兆候

```
以下の現象が頻発する場合、即座にモデル切り替えを検討:

緊急度: 高
  1. 指定したモデルを勝手に変更する
  2. 同じ指示を5回繰り返しても実行しない
  3. Reward Hacking（問題の隠蔽）が増える

緊急度: 中
  4. 応答が極端に遅い、またはタイムアウト頻発
  5. 深夜（負荷が低い時間）でも品質が低い

対応フロー:
  1. 即座に Sonnet に切り替えて比較
  2. 問題をメモに記録（日時、症状、頻度）
  3. 改善しない場合は代替ツールを検討
  4. 1週間後に再評価
```

---

## 品質維持チェックリスト

### 実装中（常時監視）

```
[ ] コードを監視している（Vibe Coding していない）
[ ] Plan Mode で事前承認している
[ ] モデルが勝手に変更されていない
[ ] Reward Hacking の兆候がない
  [ ] コメントアウトで問題を隠していない
  [ ] try-catch で例外を握りつぶしていない
  [ ] フェイクログを出力していない
```

### 実装完了時

```
[ ] 「なぜ動いているか」を説明できる
[ ] エッジケースが考慮されている
[ ] fallback / try-catch が適切
[ ] テストが通る
```
